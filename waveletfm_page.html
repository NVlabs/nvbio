<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>NVBIO: Protein Search using Wavelet Trees and an FM-index</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">NVBIO</a></li><li class="navelem"><a class="el" href="nvbio_page.html">NVBIO</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Protein Search using Wavelet Trees and an FM-index </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt></dt><dd>In <a href="https://github.com/NVlabs/nvbio/blob/master/examples/waveletfm/waveletfm.cu">this example</a>, we want to show NVBIO's support for larger alphabets, particularly showing the composability of compact string representations like <a class="el" href="strings_page.html#WaveletTreeSection">Wavelet Trees</a>, and self-compressed indices like the <a class="el" href="fmindex_page.html#FMIndexSection">FM-index</a>. We are hence going to build a small app performing pattern matching on a protein string.</dd></dl>
<h1><a class="anchor" id="WaveletFM_BWTBuildingSection"></a>
Building the BWT</h1>
<dl class="section user"><dt></dt><dd>If we want to build an FM-index, the first thing is computing the BWT of the database string we want to index. In this example, we'll use a very naive string containing all protein characters in a row - but in a real app this string might contain millions of entries, hence we'll do this using NVBIO's very fast parallel construction algorithm running on a CUDA device.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="bgzip_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;waveletfm... started\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// this string will be our protein database we want to search in - just a short string</span></div>
<div class="line">    <span class="comment">// with all protein characters in sequence</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* proteins = <span class="stringliteral">&quot;ACDEFGHIKLMNOPQRSTVWYBZX&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> text_len = 24;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print the text</span></div>
<div class="line">    <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;  text: %s\n&quot;</span>, proteins);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// allocate a host packed vector</span></div>
<div class="line">    PackedVector&lt;host_tag,8u,true&gt; h_text( text_len );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pack the string</span></div>
<div class="line">    from_string&lt;PROTEIN&gt;( proteins, proteins + text_len, h_text.begin() );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// copy it to the device</span></div>
<div class="line">    PackedVector&lt;device_tag,8u,true&gt; d_text( h_text );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// allocate a vector for the BWT</span></div>
<div class="line">    PackedVector&lt;device_tag,8u,true&gt; d_bwt( text_len + 1 );</div>
<div class="line"></div>
<div class="line">    BWTParams bwt_params;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build the BWT</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> primary = <a class="code" href="group___sufsort.html#gab8dbd556689a937c97d8f61a43b216b1">cuda::bwt</a>( text_len, d_text.begin(), d_bwt.begin(), &amp;bwt_params );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print the BWT</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">char</span> proteins_bwt[ 25 ];</div>
<div class="line"></div>
<div class="line">        to_string&lt;PROTEIN&gt;( d_bwt.begin(), d_bwt.begin() + text_len, proteins_bwt );</div>
<div class="line"></div>
<div class="line">        proteins_bwt[24] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;  bwt: %s (primary %u)\n&quot;</span>, proteins_bwt, primary);</div>
<div class="line">    }</div>
<div class="line">    ...</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Done: if everything works correctly, this should print the string "bwt: XACDEFGHIKLMNOPQRSTVWYBZ (primary 1)".</dd></dl>
<h1><a class="anchor" id="WaveletFM_WaveletTreeSection"></a>
It's a large alphabet, let's use a Wavelet Tree</h1>
<dl class="section user"><dt></dt><dd>Compared to DNA, the protein alphabet is a largish one, with 24 letters. If we were to use a plain BWT encoding and a standard <a class="el" href="fmindex_page.html#RankDictionarySection">rank dictionary</a> based on sparse occurrence tables to build an FM-index, we would need storage proportional to the string length times the size of the alphabet. The thing is made even worse by the fact that, for the purpose of efficient string packing, NVBIO treats protein characters as 8-bit characters, as 5-bit packing would need cumbersome, slow bit-manipulation logic (because individual characters would stride word boundaries). This means an FM-index would require 128 times more storage than for the 2-bit DNA alphabet!</dd></dl>
<dl class="section user"><dt></dt><dd>But no worries: we can encode our BWT using <a class="el" href="strings_page.html#WaveletTreeSection">Wavelet Trees</a>, a wonderful succint data structure designed to encode large alphabet strings in small space (proportional to the string length times the number of <em>bits</em> required to represent each symbol, i.e. the <em>logarithm</em> of the alphabet size) while allowing O(1) ranking. Let's build a wavelet tree, then...</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// define our wavelet tree storage type and its plain view</span></div>
<div class="line">typedef WaveletTreeStorage&lt;device_tag&gt;                          wavelet_tree_type;</div>
<div class="line"><span class="keyword">typedef</span> WaveletTreeStorage&lt;device_tag&gt;::const_plain_view_type   wavelet_tree_view_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// build a wavelet tree</span></div>
<div class="line">wavelet_tree_type wavelet_bwt;</div>
<div class="line"></div>
<div class="line"><span class="comment">// setup the wavelet tree</span></div>
<div class="line"><a class="code" href="group___wavelet_tree_module.html#ga94dd828ab4a302afaacaf19703489e9b">setup</a>( text_len, d_bwt.begin(), wavelet_bwt );</div>
<div class="line">...</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Et voila. At this point, we could even throw away the original bwt (the vector <em>d_bwt</em>), as the wavelet bwt encodes all the information we need. Notice that, behind the curtains, the wavelet tree construction is parallelized, in this case on the device.</dd></dl>
<h1><a class="anchor" id="WaveletFM_FMIndexSection"></a>
Building and querying the FM-index</h1>
<dl class="section user"><dt></dt><dd>We now need to setup an FM-index on top of the wavelet bwt. Remember the basic <a class="el" href="fmindex_page.html#FMIndexSection">fm_index</a> class has three template parameters, a TRankDictionary type, a TSuffixArray type, and a TL2 type. These represent the kind of <a class="el" href="fmindex_page.html#RankDictionarySection">rank dictionary</a> used to encode the bwt (in our case the wavelet tree), the sampled suffix array (if needed), and an iterator to the L2 table (a table containing the sum of all character frequencies). In our case, we want to specialize this cass to use: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>the WaveletTreeStorage::const_plain_view_type class</li>
<li>a null_type suffix array (as the sampled suffix array is only needed for locating, which we won't do here - though it might be needed in a real app)</li>
<li>an L2 iterator to a device <a class="el" href="structnvbio_1_1vector.html">nvbio::vector</a> of integers, i.e. nvbio::vector&lt;device_tag,uint32&gt;::const_iterator</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Notice that the default value for the TL2 iterator is null_type, in which case a raw pointer will be used. However, in this example we want to show that all of NVBIO's data structures, even when instanced on the device, can be accessed and used for computing from the host just as well - albeit potentially paying a very long latency tax when unified memory is not present. This can be achieved using proper iterators, which know the memory space they are pointing to, and issue cuda mem-copies when dereferenced.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">    ...</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;::const_iterator</a>            l2_iterator;</div>
<div class="line">    <span class="keyword">typedef</span> fm_index&lt;wavelet_tree_view_type, null_type, l2_iterator&gt;    fm_index_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// take the const view of the wavelet tree</span></div>
<div class="line">    <span class="keyword">const</span> wavelet_tree_view_type wavelet_bwt_view = <a class="code" href="structnvbio_1_1cuda_1_1_ping_pong_queues.html#aadbb598b3a8d9501ca1ab7b28e78e320">plain_view</a>( (<span class="keyword">const</span> wavelet_tree_type&amp;)wavelet_bwt );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build the L2 vector</span></div>
<div class="line">    <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;</a> L2(257);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// note we perform this on the host, even though the wavelet tree is on the device -</span></div>
<div class="line">    <span class="comment">// gonna be slow, but it&#39;s not much stuff, and this is just an example anyway...</span></div>
<div class="line">    <span class="comment">// and we just want to show that NVBIO is designed to make everything work!</span></div>
<div class="line">    L2[0] = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> i = 1; i &lt;= 256; ++i)</div>
<div class="line">        L2[i] = L2[i-1] + <a class="code" href="group___f_m_index.html#ga3626bf327979888cf1df84910c2847cb">rank</a>( wavelet_bwt_view, text_len, i-1u );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build the FM-index</span></div>
<div class="line">    <span class="keyword">const</span> fm_index_type fmi(</div>
<div class="line">        text_len,</div>
<div class="line">        primary,</div>
<div class="line">        L2.begin(),</div>
<div class="line">        wavelet_bwt_view,</div>
<div class="line">        null_type() );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// do some string matching using our newly built FM-index - once again</span></div>
<div class="line">    <span class="comment">// we are doing it on the host, though all data is on the device: the entire</span></div>
<div class="line">    <span class="comment">// loop would be better moved to the device in a real app.</span></div>
<div class="line">    <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;  string matching:\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> i = 0; i &lt; text_len; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// match the i-th suffix of the text</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> pattern_len = text_len - i;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// compute the SA range containing the occurrences of the pattern we are after</span></div>
<div class="line">        <span class="keyword">const</span> uint2 range = <a class="code" href="group___f_m_index.html#gac4ed217af75673d34c35eaddbf80d11a">match</a>( fmi, d_text.begin() + i, pattern_len );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// print the number of occurrences of our pattern, equal to the SA range size</span></div>
<div class="line">        <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;    rank(%s): %u\n&quot;</span>, proteins + i, 1u + range.y - range.x);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;waveletfm... done\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Compile, and run. With a bit of luck, you should see the following output: <pre class="fragment">*  info    : waveletfm... started
*  info    :   text: ACDEFGHIKLMNOPQRSTVWYBZX
*  info    :   bwt: XACDEFGHIKLMNOPQRSTVWYBZ (primary 1)
*  info    :   string matching:
*  info    :     rank(ACDEFGHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(CDEFGHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(DEFGHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(EFGHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(FGHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(GHIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(HIKLMNOPQRSTVWYBZX): 1
*  info    :     rank(IKLMNOPQRSTVWYBZX): 1
*  info    :     rank(KLMNOPQRSTVWYBZX): 1
*  info    :     rank(LMNOPQRSTVWYBZX): 1
*  info    :     rank(MNOPQRSTVWYBZX): 1
*  info    :     rank(NOPQRSTVWYBZX): 1
*  info    :     rank(OPQRSTVWYBZX): 1
*  info    :     rank(PQRSTVWYBZX): 1
*  info    :     rank(QRSTVWYBZX): 1
*  info    :     rank(RSTVWYBZX): 1
*  info    :     rank(STVWYBZX): 1
*  info    :     rank(TVWYBZX): 1
*  info    :     rank(VWYBZX): 1
*  info    :     rank(WYBZX): 1
*  info    :     rank(YBZX): 1
*  info    :     rank(BZX): 1
*  info    :     rank(ZX): 1
*  info    :     rank(X): 1
*  info    : waveletfm... done
* </pre></dd></dl>
<dl class="section user"><dt></dt><dd>Showing that, indeed, there's one match for each suffix of the original string.</dd></dl>
<p>Next: <a class="el" href="proteinsw_page.html">Smith-Waterman Alignment of Protein Strings</a> Top: <a class="el" href="nvbio_page.html">NVBIO</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 23 2015 19:36:55 for NVBIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
