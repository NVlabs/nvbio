<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>NVBIO: All-Mapping using an FM-index</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">NVBIO</a></li><li class="navelem"><a class="el" href="nvbio_page.html">NVBIO</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">All-Mapping using an FM-index </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt></dt><dd>NVBIO tries to make it easy to write modern bioinformatics applications exploiting parallel architectures. In this page we'll see how to apply it to build a prototype <a class="el" href="fmindex_page.html">FM-index</a> based all-mapper.<br/>
</dd></dl>
<h1><a class="anchor" id="InputSection"></a>
Input</h1>
<dl class="section user"><dt></dt><dd>The first step for a reference-based aligner is loading a reference index, and streaming a set of reads. Let's start by loading the reference sequence and its FM-index, using the corresponding <a class="el" href="sequence_io_page.html">Sequence</a> and <a class="el" href="fmindex_io_page.html">FM-Index I/O</a> classes.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">nvbio/basic/timer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="console_8h.html">nvbio/basic/console.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html" title="Define host / device vectors. ">nvbio/basic/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="shared__pointer_8h.html">nvbio/basic/shared_pointer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna_8h.html">nvbio/basic/dna.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sequence_8h.html">nvbio/io/sequence/sequence.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="io_2fmindex_2fmindex_8h.html">nvbio/io/fmindex/fmindex.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;util.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="bgzip_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// perform some basic option parsing</span></div>
<div class="line">    Params params( argc-2, argv );</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* reads = argv[argc-1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* index = argv[argc-2];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// load a reference sequence in RAM</span></div>
<div class="line">    <a class="code" href="group___sequence_i_o.html#gaeda29063a8a35631e18372d8a6001e27" title="a SequenceData object stored in host memory ">io::SequenceDataHost</a> h_ref;</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group___sequence_i_o.html#ga51edb4491c012a5c6c91b8de1472cb13">io::load_sequence_file</a>( <a class="code" href="group___alphabets_module.html#ggacd06da18687b2a345bef56a9fdad1a48a6c8c7655bd0085241eed95780a3aa4c4" title="4-letter DNA alphabet { A,C,G,T } ">DNA</a>, &amp;h_ref, index ))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="console_8cpp.html#a4666077df5b6eb45547efd029fc3689e">log_error</a>(stderr, <span class="stringliteral">&quot;    failed loading reference \&quot;%s\&quot;\n&quot;</span>, index);</div>
<div class="line">        <span class="keywordflow">return</span> 1u;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// load an FM-index in RAM</span></div>
<div class="line">    io::FMIndexDataHost h_fmi;</div>
<div class="line">    <span class="keywordflow">if</span> (!h_fmi.load( index, <a class="code" href="group___sequence_i_o.html#ggaa3df48d0ab11675e05f2c34fb70e5673a8ff7c616502f05c17e72a0b525ff9d61">io::FMIndexData::FORWARD</a> | io::FMIndexData::SA ))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="console_8cpp.html#a4666077df5b6eb45547efd029fc3689e">log_error</a>(stderr, <span class="stringliteral">&quot;    failed loading index \&quot;%s\&quot;\n&quot;</span>, index);</div>
<div class="line">        <span class="keywordflow">return</span> 1u;</div>
<div class="line">    }</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>Besides some simple option parsing, at this point we have an application that loads an FM-index from disk into system memory, including the genome, its forward BWT and the Sampled Suffix Array. At this point, if we want our mapper to run on the GPU we can copy the FM-index in device memory with a single line, again specifying which of its components to load. Rather than keeping it on the stack we will store it in a <em>Pipeline</em> object, which we'll use to keep all the state of our mapper.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Pipeline</div>
<div class="line">{</div>
<div class="line">    Params                                params;    <span class="comment">// the mapping params</span></div>
<div class="line">    SharedPointer&lt;io::SequenceDataDevice&gt; ref_data;  <span class="comment">// the device reference</span></div>
<div class="line">    SharedPointer&lt;io::FMIndexDataDevice&gt;  fm_data;   <span class="comment">// the device FM-index</span></div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">...</div>
<div class="line">    Pipeline pipeline;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// save the program options</span></div>
<div class="line">    pipeline.params = params;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build the device index</span></div>
<div class="line">    pipeline.ref_data = <span class="keyword">new</span> <a class="code" href="group___sequence_i_o.html#ga320e6b720c7ea82793f41b21c184d960" title="a SequenceData object stored in device memory ">io::SequenceDataDevice</a>( h_ref );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// build the device index</span></div>
<div class="line">    pipeline.fm_data = <span class="keyword">new</span> io::FMIndexDataDevice( h_fmi, <a class="code" href="group___sequence_i_o.html#ggaa3df48d0ab11675e05f2c34fb70e5673a8ff7c616502f05c17e72a0b525ff9d61">io::FMIndexData::FORWARD</a> |</div>
<div class="line">                                                         io::FMIndexData::SA );</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>The second second step is to start streaming reads in; NVBIO's philosophy here is to use a batched approach, where the size of the batch will roughly determine the amount of available parallelism in the rest of the pipeline. In order to amortize fixed costs (e.g. grid launch / synchronization overhead) it's good to allow for as much parallelism as possible given your memory constraints - but as a rough guideline, suffice it to say that lightweight kernels should have at least ~128K items to process, possibly more (for example, sorting performance saturates at 16-32M keys).<br/>
 So if some stages of the alignment pipeline will parallelize across reads, it would be good to have at least 1M or so to process. Obviously, one million reads could require plenty of memory if the reads are long, so we might want to cap the maximum number of base pairs as well:</dd></dl>
<div class="fragment"><div class="line">...</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> batch_reads   =   1*1024*1024;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> batch_bps     = 100*1024*1024;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// open a read file, storing for each read both its forward and its reverse-complemented representations</span></div>
<div class="line">    SharedPointer&lt;io::SequenceDataStream&gt; read_data_file(</div>
<div class="line">        <a class="code" href="group___sequence_i_o.html#ga249422025262954363e6857c7903dfa6">io::open_sequence_file</a>(</div>
<div class="line">            reads,</div>
<div class="line">            <a class="code" href="group___sequence_i_o.html#gga3415ac326089788da99884c50b8ccb16a014958857dbbddee90a1489d4fa5d3d2" title="phred quality + 33 ">io::Phred33</a>,</div>
<div class="line">            2*params.max_reads,</div>
<div class="line">            <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a>(-1),</div>
<div class="line">            <a class="code" href="group___sequence_i_o.html#gaa3df48d0ab11675e05f2c34fb70e5673">io::SequenceEncoding</a>( <a class="code" href="group___sequence_i_o.html#ggaa3df48d0ab11675e05f2c34fb70e5673a8ff7c616502f05c17e72a0b525ff9d61">io::FORWARD</a> | <a class="code" href="group___sequence_i_o.html#ggaa3df48d0ab11675e05f2c34fb70e5673a5655652c9d1c1d3eccf23c78a7cb120f">io::REVERSE_COMPLEMENT</a> ) ) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check whether the file opened correctly</span></div>
<div class="line">    <span class="keywordflow">if</span> (read_data_file == NULL || read_data_file-&gt;is_ok() == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="console_8cpp.html#a4666077df5b6eb45547efd029fc3689e">log_error</a>(stderr, <span class="stringliteral">&quot;    failed opening file \&quot;%s\&quot;\n&quot;</span>, reads);</div>
<div class="line">        <span class="keywordflow">return</span> 1u;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">               <a class="code" href="group___sequence_i_o.html#gaeda29063a8a35631e18372d8a6001e27" title="a SequenceData object stored in host memory ">io::SequenceDataHost</a> h_read_data;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// start looping to consume the input reads</span></div>
<div class="line">    <span class="keywordflow">while</span> (1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// load a batch of reads</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group___sequence_i_o.html#ga0b124ee3d2c51b0a1f555c91ad4948a2">io::next</a>( <a class="code" href="group___alphabets_module.html#ggacd06da18687b2a345bef56a9fdad1a48a312b63ba76d209928476bcefde8f124d" title="5-letter DNA + N alphabet { A,C,G,T,N } ">DNA_N</a>, &amp;h_read_data, read_data_file, batch_reads, batch_bps ) == 0);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;  loading reads... started\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// copy it to the device</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___sequence_i_o.html#ga320e6b720c7ea82793f41b21c184d960" title="a SequenceData object stored in device memory ">io::SequenceDataDevice</a> d_read_data( *h_read_data );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// remember we generated two strands per input read...</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_reads = d_read_data.size() / 2;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;  loading reads... done\n&quot;</span>);</div>
<div class="line">        <a class="code" href="console_8cpp.html#a3f1311cb7f0df2f027275d682ccf0918">log_info</a>(stderr, <span class="stringliteral">&quot;    %u reads\n&quot;</span>, n_reads);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// do the real mapping work</span></div>
<div class="line">        <a class="code" href="group___mapping.html#gad30b05e1249763bbda8b4745c92a42ae">map</a>( pipeline, d_read_data );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>Now we are ready to start the real mapping work. In order to do it, we'll need to store another data structure in our pipeline, namely the <a class="el" href="fmindex_page.html#FMIndexFilters">FMIndexFilter</a>. This data structure is just a context for performing FM-index based filtering, i.e. the process of finding potential matches of a set of strings using an FM-index.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Pipeline</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> io::FMIndexDataDevice::fm_index_type        fm_index_type;  <span class="comment">// the fm-index view type</span></div>
<div class="line">    <span class="keyword">typedef</span> FMIndexFilterDevice&lt;fm_index_type&gt;          fm_filter_type; <span class="comment">// the fm-index filter type</span></div>
<div class="line"></div>
<div class="line">    Params                                params;    <span class="comment">// the mapping params</span></div>
<div class="line">    SharedPointer&lt;io::SequenceDataDevice&gt; ref_data;  <span class="comment">// the device reference</span></div>
<div class="line">    SharedPointer&lt;io::FMIndexDataDevice&gt;  fm_data;   <span class="comment">// the device FM-index</span></div>
<div class="line">    fm_filter_type                        fm_filter; <span class="comment">// the FM-index filter</span></div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="section user"><dt></dt><dd>Here you go, ready to write the bulk of the aligner.</dd></dl>
<h1><a class="anchor" id="MappingSection"></a>
Mapping</h1>
<dl class="section user"><dt></dt><dd>We'll write a simple seed &amp; extend aligner, so the first thing we'll want to do is split our reads in equal segments. As shown in the previous example, the collection of these seeds can be seen as an InfixSet . Let's start with some boiler-plate code to make sure we have everythin we need:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group___mapping.html#gad30b05e1249763bbda8b4745c92a42ae">map</a>(Pipeline&amp; pipeline, <span class="keyword">const</span> io::SequenceDataAccess&lt;DNA_N&gt; reads)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// the reads can be accessed as a string-set, of this type</span></div>
<div class="line">    <span class="keyword">typedef</span> io::SequenceDataAccess&lt;DNA&gt;::sequence_string_set_type               genome_string;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the reads can be accessed as a string-set, of this type</span></div>
<div class="line">    <span class="keyword">typedef</span> io::SequenceDataAccess&lt;DNA_N&gt;::sequence_string_set_type             read_string_set_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the seeds will be infixes of a string-set, with this coordinates type</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="group___string_sets_module.html#ga71ecfc758a63a4bcf233ea33ed801f42">string_set_infix_coord_type</a>                                         infix_coord_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// and we&#39;ll store them in a device vector</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,infix_coord_type&gt;</a>                          infix_vector_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// finally, this will be the type of their infix-set</span></div>
<div class="line">    <span class="keyword">typedef</span> InfixSet&lt;read_string_set_type, const string_set_infix_coord_type*&gt;  seed_string_set_type;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// fetch the program options</span></div>
<div class="line">    <span class="keyword">const</span> Params&amp; params = pipeline.params;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fetch the genome string</span></div>
<div class="line">    <span class="keyword">const</span> io::SequenceDataAccess&lt;DNA&gt; genome_access( *pipeline.ref_data );</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a>        genome_len = genome_access.bps();</div>
<div class="line">    <span class="keyword">const</span> genome_string genome( genome_access.sequence_stream() );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fetch an fm-index view</span></div>
<div class="line">    <span class="keyword">const</span> Pipeline::fm_index_type fm_index = pipeline.fm_data-&gt;index();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fetch the fm-index filter</span></div>
<div class="line">    Pipeline::fm_filter_type&amp; fm_filter = pipeline.fm_filter;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// prepare some vectors to store the query qgrams</span></div>
<div class="line">    infix_vector_type seed_coords;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// extract the seeds</span></div>
<div class="line">    <span class="keyword">const</span> read_string_set_type read_string_set = reads.sequence_string_set();</div>
<div class="line">    <span class="keyword">const</span> seed_string_set_type seed_string_set = extract_seeds(</div>
<div class="line">        read_string_set,</div>
<div class="line">        params.seed_len,</div>
<div class="line">        params.seed_intv,</div>
<div class="line">        seed_coords );</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>The next step is mapping the seeds using the FM-index filter; we start by <em>ranking</em> their occurrences:</dd></dl>
<div class="fragment"><div class="line">...</div>
<div class="line">    <span class="comment">// first step: rank the query seeds</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemgpu.html#a6a8a9b2cd0011a49aca6a25517024818">uint64</a> n_hits = fm_filter.rank( fm_index, seed_string_set );</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>Now, each seed might have mapped to a whole range of suffixes in the Suffix Array of the genome, and all those locations are potential candidates for a valid alignment. We want to visit them all, which means we need to <em>locate</em> their coordinates.<br/>
 Notice that this process might involve a severe data expansion, as some seeds might map to millions of genome locations: hence, we cannot simply locate all the <em>n_hits</em> in one go. The <a class="el" href="fmindex_page.html#FMIndexFilters">FMIndexFilter</a> interface gives us the chance to do it in batches, while doing the delicate job of parallelizing work at the finest possible grain and with the most evenly distributed load-balancing: i.e. spreading the variable sized suffix array ranges across multiple threads, so that each thread gets a single hit to locate. Well, in practice, you can ignore this, as NVBIO will do it for you. The only thing you need to remember is to process your hits in large batches:</dd></dl>
<div class="fragment"><div class="line">...</div>
<div class="line">typedef uint2 hit_type; <span class="comment">// each hit will be a (genome-pos,seed-id) coordinate pair</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// prepare storage for the output hits</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,hit_type&gt;</a>      hits( batch_size );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;</a>        out_reads( batch_size );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,int16&gt;</a>         out_scores( batch_size );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint8&gt;</a>         temp_storage;</div>
<div class="line"></div>
<div class="line"><span class="comment">// loop through large batches of hits and locate &amp; merge them</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespacemgpu.html#a6a8a9b2cd0011a49aca6a25517024818">uint64</a> hits_begin = 0; hits_begin &lt; n_hits; hits_begin += batch_size)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemgpu.html#a6a8a9b2cd0011a49aca6a25517024818">uint64</a> hits_end = <a class="code" href="group___basic_utils.html#gaeeb2406339f4edfcee3f007aaccd478e">nvbio::min</a>( hits_begin + batch_size, n_hits );</div>
<div class="line"></div>
<div class="line">    fm_filter.locate(</div>
<div class="line">        hits_begin,      <span class="comment">// the beginning of the range of hits to locate</span></div>
<div class="line">        hits_end,        <span class="comment">// the end of the range of hits to locate</span></div>
<div class="line">        hits.begin() );  <span class="comment">// the output vector to be filled</span></div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>At this point, remember the hit coordinates refer to the seeds, not to the reads they belong to. We hence want to convert them to <em>diagonals</em> of the genome/read matrices, and we do this employing the <a class="el" href="group___primitives.html#ga0b41de45962c3b82d1fb26c5aa4b3c6e">transform()</a> <a class="el" href="primitives_page.html">parallel primitive</a>:</dd></dl>
<div class="fragment"><div class="line">...</div>
<div class="line">    <span class="comment">// transform the (index-pos,seed-id) hit coordinates into diagonals</span></div>
<div class="line">    nvbio::transform&lt;device_tag&gt;(</div>
<div class="line">        hits_end - hits_begin,</div>
<div class="line">        hits.begin(),</div>
<div class="line">        hits.begin(),</div>
<div class="line">        hit_to_diagonal( <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( seed_coords ) ) );</div>
<div class="line">...</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// transform an (index-pos,seed-id) hit into a diagonal (text-pos = index-pos - seed-pos, read-id)</span></div>
<div class="line"><span class="keyword">struct </span>hit_to_diagonal</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> uint2  argument_type;</div>
<div class="line">    <span class="keyword">typedef</span> uint2  result_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// constructor</span></div>
<div class="line">    <a class="code" href="types_8h.html#a56a96b87facf0565fee0a1fe27ffc2f0">NVBIO_FORCEINLINE</a> <a class="code" href="types_8h.html#aae8f5a3072675fd93df702e927eaf540">NVBIO_HOST_DEVICE</a></div>
<div class="line">    hit_to_diagonal(<span class="keyword">const</span> <a class="code" href="group___string_sets_module.html#ga71ecfc758a63a4bcf233ea33ed801f42">string_set_infix_coord_type</a>* _seed_coords) : seed_coords(_seed_coords) {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// functor operator</span></div>
<div class="line">    <a class="code" href="types_8h.html#a56a96b87facf0565fee0a1fe27ffc2f0">NVBIO_FORCEINLINE</a> <a class="code" href="types_8h.html#aae8f5a3072675fd93df702e927eaf540">NVBIO_HOST_DEVICE</a></div>
<div class="line">    uint2 operator() (<span class="keyword">const</span> uint2 hit)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> index_pos = hit.x;</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> seed_id   = hit.y;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___string_sets_module.html#ga71ecfc758a63a4bcf233ea33ed801f42">string_set_infix_coord_type</a> seed = seed_coords[ seed_id ];</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> read_pos = <a class="code" href="group___string_sets_module.html#gab2ab7f592829b1b11ea1f84aa26017bc">infix_begin</a>( seed );</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> read_id  =   <a class="code" href="group___string_sets_module.html#ga52dda41552f24292779de0c589b50e38">string_id</a>( seed );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> make_uint2( index_pos - read_pos, read_id );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___string_sets_module.html#ga71ecfc758a63a4bcf233ea33ed801f42">string_set_infix_coord_type</a>* seed_coords;</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>We are finally ready for the <em>extension</em> or <em>verification</em> phase: we need to check if the candidate hits identified by the seeds are true alignments or not, i.e. whether they map to within a certain edit-distance from the reference genome. We'll do this using the banded <a class="el" href="alignment_page.html#AlignersAnchor">Myers bit-vector</a> aligner, applied to the <a class="el" href="alignment_page.html#BatchAlignmentSection">batch alignment</a> problem of aligning the string-set of reads associated to all hits against the string-set of corresponding genome locations. Both these string-sets can be thought of as <em>sparse</em> string sets, i.e. sparse collections of substrings of: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>the contiguously packed string of input reads</li>
<li>the reference genome</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">        ...</div>
<div class="line">        <span class="comment">// build the set of read infixes</span></div>
<div class="line">        nvbio::transform&lt;device_tag&gt;(</div>
<div class="line">            hits_end - hits_begin</div>
<div class="line">            hits.begin(),</div>
<div class="line">            read_infix_coords.begin(),</div>
<div class="line">            <a class="code" href="structread__infixes.html">read_infixes</a>( <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( reads ) ) );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build the set of genome infixes</span></div>
<div class="line">        nvbio::transform&lt;device_tag&gt;(</div>
<div class="line">            hits_end - hits_begin</div>
<div class="line">            hits.begin(),</div>
<div class="line">            genome_infix_coords.begin(),</div>
<div class="line">            <a class="code" href="structgenome__infixes.html">genome_infixes&lt;BAND_LEN&gt;</a>( genome_len, <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( reads ) ) );</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,string_infix_coord_type&gt;::const_iterator</a> infix_iterator;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">typedef</span> io::SequenceDataAccess&lt;DNA_N&gt;::sequence_stream_type      read_stream;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> SparseStringSet&lt;read_stream,infix_iterator&gt; read_infix_set(</div>
<div class="line">            hits_end - hits_begin,</div>
<div class="line">            reads.sequence_stream(),</div>
<div class="line">            read_infix_coords.begin() );</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> SparseStringSet&lt;genome_string,infix_iterator&gt; genome_infix_set(</div>
<div class="line">            hits_end - hits_begin,</div>
<div class="line">            genome,</div>
<div class="line">            genome_infix_coords.begin() );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// spawn a batched banded DP alignment</span></div>
<div class="line">        <span class="keyword">typedef</span> aln::MyersTag&lt;5u&gt; myers_dna5_tag;</div>
<div class="line"></div>
<div class="line">        aln::batch_banded_alignment_score&lt;BAND_LEN&gt;(</div>
<div class="line">            aln::make_edit_distance_aligner&lt;aln::SEMI_GLOBAL, myers_dna5_tag&gt;(),</div>
<div class="line">            read_infix_set,</div>
<div class="line">            genome_infix_set,</div>
<div class="line">            sinks.begin(),</div>
<div class="line">            <a class="code" href="group___batch_scheduler.html#ga8d26fb0c847e458b838e5f98893af1a4">aln::DeviceThreadScheduler</a>(),</div>
<div class="line">            reads.max_read_len(),</div>
<div class="line">            reads.max_read_len() + BAND_LEN );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section user"><dt></dt><dd>Technically, we are almost done: we now have the mapping score for each candidate hit. In this tutorial we won't do anything with them, but the accompanying code actually shows how to keep track of the best scores for each read by using <em>segmented reductions</em>. </dd></dl>
<dl class="section user"><dt></dt><dd>This example should have given you an idea of how to build a pipeline based on some of NVBIO's parallel constructs, from FM-index filters to DP alignment. Hopefully, you are now set to read through the rest of the documentation and discover how many other useful tools might come to your help!</dd></dl>
<p>Top: <a class="el" href="nvbio_page.html">NVBIO</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 23 2015 23:39:50 for NVBIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
