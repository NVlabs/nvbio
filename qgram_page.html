<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>NVBIO: Q-Gram Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">NVBIO</a></li><li class="navelem"><a class="el" href="nvbio_page.html">NVBIO</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Q-Gram Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
 <img src="nvidia_cubes.png" style="position:relative; bottom:-10px; border:0px;"/>
 <br/>
 </p>
<dl class="section user"><dt></dt><dd><br/>
 This module contains a series of functions to operate on q-grams as well as two q-gram index data-structures together with very high throughput parallel construction algorithms and efficient q-gram counting primitives.</dd></dl>
<h1><a class="anchor" id="Performance"></a>
Performance</h1>
<dl class="section user"><dt></dt><dd>The first graph shows the throughput of NVBIO's <em>q-gram indexing</em> algorithms on a K40 GPU. The benchmark consists in building a q-gram index on differently sized subsets of the 8-, 16- and 20-mers obtained from a set of 1M x 150bp reads (SRR493095). Notice that the throughput increases with the size of the set, until it saturates around ~32M q-grams. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="image">
<img src="benchmark-qgram-indexing.png"  style="position:relative; bottom:-10px; border:0px;" width="85%" height="85%"/>
</div>
 </dd></dl>
<dl class="section user"><dt></dt><dd>The next graph shows the performance of NVBIO's <em>q-gram counting</em> queries. The benchmark consists in building a q-gram index on the 22-mers obtained sampling a set of 1M x 150bp reads (SRR493095) every 10 bases, and streaming the whole human genome hg19 against it to find all matching q-grams. Specifically, the graph shows the throughput of the following three stages: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><em>ranking</em>: the process of finding the range of hits matching each query q-gram in the q-gram index</li>
<li><em>locating</em>: the process of enumerating all found hits as (read-id,text-diagonal) pairs</li>
<li><em>counting</em>: the process of bucketing the found hits by diagonal (separately for each read) and counting the occurrences in each bucket </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd><div class="image">
<img src="benchmark-qgram-counting.png"  style="position:relative; bottom:-10px; border:0px;" width="85%" height="85%"/>
</div>
</dd></dl>
<h1><a class="anchor" id="QGramIndicesSection"></a>
Q-Gram Indices</h1>
<dl class="section user"><dt></dt><dd>Q-gram indices are data-structures providing fast searching of exact or approximate <em>q-grams</em> (or k-mers), i.e. short strings of text containing <em>q</em> symbols. This module provides two such data-structures: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>the <a class="el" href="group___q_group_index.html">Q-Group Index</a>, replicating the data-structure described in:<br/>
 <em>Massively parallel read mapping on GPUs with PEANUT</em> <br/>
 Johannes Koester and Sven Rahmann <br/>
 <a href="http://arxiv.org/pdf/1403.1706v1.pdf">http://arxiv.org/pdf/1403.1706v1.pdf</a> <br/>
 this data-structure requires O(A^q) bits of storage in the alphabet-size <em>A</em> and the q-gram length <em>q</em> (to be precise, 2*A^q bits + (min(A^q,|T|) + |T|) words), and provides O(1) query time; <br/>
 <br/>
</li>
<li>the compact <a class="el" href="group___q_gram_index.html">Q-Gram Index</a>, which can be built over a string T, with memory consumption and query time proportional to O(|T|) and O(log(unique(T))) respectively, where <em>unique(T)</em> is the number of unique q-grams in T. This is achieved by keeping a plain sorted list of the unique q-grams in T, together with an index of their occurrences in the original string T. This data-structure offers up to 5x higher construction speed and a potentially unbounded improvement in memory consumption compared to the <a class="el" href="group___q_group_index.html">Q-Group Index</a>, though the query time is asymptotically higher.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Q-gram indices can be built both on strings and on string sets (in which case we call them <em>set-indices</em>). The difference relies on the format of the coordinates associated to their q-grams: for strings, the coordinates are simple linear indices, whereas for string-sets the coordinates are <em>(string-id,string-position)</em> index pairs. </dd></dl>
<dl class="section user"><dt></dt><dd>The following code sample shows how to build a QGramIndex over a simple string: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="qgram_8h.html">nvbio/qgram/qgram.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html" title="Define host / device vectors. ">nvbio/basic/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna_8h.html">nvbio/basic/dna.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// consider a DNA string in ASCII format</span></div>
<div class="line">const <span class="keywordtype">char</span>*  a_string = <span class="stringliteral">&quot;ACGTACGTACGTACGTACGTACGTACGTACGT&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> string_len = strlen( a_string );</div>
<div class="line"></div>
<div class="line"><span class="comment">// convert the string to a 2-bit DNA alphabet</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;host_tag,uint8&gt;</a> h_string( string_len );</div>
<div class="line"><a class="code" href="namespacenvbio.html#aa9ee0534e5881be7835abcaa242a9f28">string_to_dna</a>( a_string, string_len, h_string.begin() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy the string to the device</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint8&gt;</a> d_string( h_string );</div>
<div class="line"></div>
<div class="line"><span class="comment">// build a q-gram index on the device</span></div>
<div class="line">QGramIndexDevice qgram_index;</div>
<div class="line"></div>
<div class="line">qgram_index.build(</div>
<div class="line">    20u,                        <span class="comment">// q-group size</span></div>
<div class="line">    2u,                         <span class="comment">// the alphabet size, in bits</span></div>
<div class="line">    string_len,                 <span class="comment">// the length of the string we want to index</span></div>
<div class="line">    d_string.begin() );         <span class="comment">// the string we want to index</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The next example shows how to do the same with a string-set: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="qgram_8h.html">nvbio/qgram/qgram.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html" title="Define host / device vectors. ">nvbio/basic/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string__set_8h.html">nvbio/strings/string_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dna_8h.html">nvbio/basic/dna.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// consider a DNA string in ASCII format</span></div>
<div class="line">const <span class="keywordtype">char</span>*  a_string = <span class="stringliteral">&quot;ACGTACGTACGTACGTACGTACGTACGTTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTTACGTACGTACGTACGTACGTACGTACGTACGT&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> string_len = strlen( a_string );</div>
<div class="line"></div>
<div class="line"><span class="comment">// convert the string to a 2-bit DNA alphabet</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;host_tag,uint8&gt;</a> h_string( string_len );</div>
<div class="line"><a class="code" href="namespacenvbio.html#aa9ee0534e5881be7835abcaa242a9f28">string_to_dna</a>( a_string, string_len, h_string.begin() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy the string to the device</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_strings = 2u;</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint8&gt;</a>  d_string( h_string );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;</a> d_string_offsets( n_strings+1 );</div>
<div class="line">d_string_offsets[0] = 0;                <span class="comment">// offset to the first string</span></div>
<div class="line">d_string_offsets[1] = 20;               <span class="comment">// offset to the second string</span></div>
<div class="line">d_string_offsets[2] = 40;               <span class="comment">// end of the last string</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ConcatenatedStringSet&lt;const uint8*,const uint32*&gt; string_set_type;</div>
<div class="line"><span class="keyword">const</span> string_set_type string_set(</div>
<div class="line">    n_strings,</div>
<div class="line">    <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( d_string ),</div>
<div class="line">    <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( d_string_offsets ) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// build a q-gram index on the device</span></div>
<div class="line">QGramSetIndexDevice qgram_index;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> q = 20u;</div>
<div class="line"></div>
<div class="line">qgram_index.build(</div>
<div class="line">    q,                                  <span class="comment">// q-group size</span></div>
<div class="line">    2u,                                 <span class="comment">// the alphabet size, in bits</span></div>
<div class="line">    string_set );                       <span class="comment">// the string-set we want to index</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> sometimes you might not want to index all the q-grams in your string-set, but rather extract one every N bases, or perhaps use some custom logic of your own. Through <a class="el" href="group___string_sets_module.html#SeedFunctor">Seeding Functors</a>, NVBIO provides a mechanism to customize the seeding logic. For example, the following code will extract a seed every 10 bases: <div class="fragment"><div class="line">qgram_index.build(</div>
<div class="line">    q,                                  <span class="comment">// q-group size</span></div>
<div class="line">    2u,                                 <span class="comment">// the alphabet size, in bits</span></div>
<div class="line">    string_set,                         <span class="comment">// the string-set we want to index</span></div>
<div class="line">    uniform_seeds_functor( q, 10u ) );  <span class="comment">// extract a q-gram every 10 bases</span></div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="QGramIndexQueriesSection"></a>
Q-Gram Index Queries</h1>
<dl class="section user"><dt></dt><dd>Once a q-gram index is built, it would be interesting to perform some queries on it. There's various ways to accomplish this, and here we'll show a couple. The simplest query one can do is locating for a given q-gram the range of indexed q-grams which match it exactly. This can be done as follows: <div class="fragment"><div class="line"><span class="comment">// consider a sample string - we&#39;ll want to find all matching locations between all</span></div>
<div class="line"><span class="comment">// q-grams in this string and all q-grams in the index</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* a_query_string = <span class="stringliteral">&quot;CGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA&quot;</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> query_string_len = strlen( a_query_string );</div>
<div class="line"></div>
<div class="line"><span class="comment">// convert the string to a 2-bit DNA alphabet</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;host_tag,uint8&gt;</a> h_string( query_string_len );</div>
<div class="line"><a class="code" href="namespacenvbio.html#aa9ee0534e5881be7835abcaa242a9f28">string_to_dna</a>( a_query_string, query_string_len, h_query_string.begin() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy the string to the device</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint8&gt;</a> d_query_string( h_query_string );</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> q = 20u;</div>
<div class="line"></div>
<div class="line"><span class="comment">// extract a set of query q-gram indices, say one every 3 bases</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;</a> d_query_indices;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_query_qgrams = <a class="code" href="group___string_sets_module.html#ga4267e15bcaeb5194447728a8377f0c79">enumerate_string_seeds</a>( query_string_len, uniform_seed_functor( q, 3u ), d_query_indices );</div>
<div class="line"></div>
<div class="line"><span class="comment">// build the set of query q-grams: this can be done using the string_qgram_functor</span></div>
<div class="line"><span class="comment">// to extract them; note that we need at least 20 x 2 = 40 bits per q-gram, hence we</span></div>
<div class="line"><span class="comment">// store them in a uint64 vector</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint64&gt;</a> d_query_qgrams( n_query_qgrams );</div>
<div class="line"><a class="code" href="group___q_gram.html#ga87d027afda5b0c89cc110266ba1a6c94">generate_qgrams</a>(</div>
<div class="line">  q, 2u,                                                    <span class="comment">// q-gram length, alphabet size</span></div>
<div class="line">  query_string_len, <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( d_query_string ),    <span class="comment">// input string</span></div>
<div class="line">  n_query_qgrams,                                           <span class="comment">// the number of q-grams</span></div>
<div class="line">  d_query_indices.begin(),                                  <span class="comment">// input q-gram coordinates</span></div>
<div class="line">  d_query_qgrams.begin() );                                 <span class="comment">// output q-grams</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// now sort the q-grams and their original indices, this improves coherence and throughput</span></div>
<div class="line">thrust::sort_by_key(</div>
<div class="line">    d_query_qgrams.begin(),</div>
<div class="line">    d_query_qgrams.begin() + n_query_qgrams,</div>
<div class="line">    d_query_indices.begin() );</div>
<div class="line"></div>
<div class="line"><span class="comment">// find the above q-grams</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint32&gt;</a> d_ranges( query_string_len - 20 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// use the plain-view of the q-gram index itself as a search functor, that we &quot;apply&quot;</span></div>
<div class="line"><span class="comment">// to our query q-grams to obtain the corresponding match ranges</span></div>
<div class="line"><a class="code" href="group___primitives.html#ga0b41de45962c3b82d1fb26c5aa4b3c6e">thrust::transform</a>(</div>
<div class="line">    d_query_qgrams.begin(),</div>
<div class="line">    d_query_qgrams.begin() + n_query_qgrams,</div>
<div class="line">    d_ranges.begin(),</div>
<div class="line">    <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( qgram_index ) );</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>This of course was just a toy example; in reality, you'll want to this kind of operations with much larger q-gram indices and much larger batches of queries.</dd></dl>
<h1><a class="anchor" id="QGramCountingSection"></a>
Q-Gram Counting</h1>
<dl class="section user"><dt></dt><dd>The previous example was only showing how to get the <em>ranges</em> of matching q-grams inside an index: it didn't show how to get the actual list of hits. One way to go about it is to ask the q-gram index, which given an entry inside each non-empty range, can provide its location. This can be done using the qgram_locate_functor. However, if one is interested in getting the complete list of hits things are more difficult, as the process involves a variable rate data-expansion (as each range might expand to a variable number of hits). </dd></dl>
<dl class="section user"><dt></dt><dd>The QGramFilter provides a convenient way to do this: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="qgram_2filter_8h.html">nvbio/qgram/filter.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// suppose we have the previous vectors d_query_qgrams and d_query_indices</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// find all hits using a q-gram filter</span></div>
<div class="line"><span class="keyword">typedef</span> QGramFilterDevice&lt;QGramSetIndexDevice, const uint64*, const uint32*&gt; qgram_filter_type;</div>
<div class="line"><span class="keyword">typedef</span> qgram_filter_type::hit_type                                          hit_type;</div>
<div class="line"><span class="keyword">typedef</span> qgram_filter_type::diagonal_type                                     diagonal_type;</div>
<div class="line"></div>
<div class="line">qgram_filter_type qgram_filter;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_hits = qgram_filter.rank(</div>
<div class="line">    qgram_index,</div>
<div class="line">    n_query_qgrams,</div>
<div class="line">    <a class="code" href="namespacenvbio.html#a8ad991c39278eb9e0d0000f2b12031da">nvbio::raw_pointer</a>( d_query_qgrams ),</div>
<div class="line">    <a class="code" href="namespacenvbio.html#a8ad991c39278eb9e0d0000f2b12031da">nvbio::raw_pointer</a>( d_query_indices ) );</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// loop through large batches of hits and locate them</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> batch_size = 16*1024*1024;             <span class="comment">// 16M hits per batch</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// reserve enough storage for each batch</span></div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,hit_type&gt;</a> hits( batch_size );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> hits_begin = 0; hits_begin &lt; n_hits; hits_begin += batch_size)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> hits_end = <a class="code" href="group___basic_utils.html#gaeeb2406339f4edfcee3f007aaccd478e">nvbio::min</a>( hits_begin + batch_size, n_hits );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// locate all hits in the range [hits_begin, hits_end)</span></div>
<div class="line">    qgram_filter.locate(</div>
<div class="line">        hits_begin,</div>
<div class="line">        hits_end,</div>
<div class="line">        hits.begin() );</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> the hit coordinates are different according to the type of q-gram index;<ul>
<li>for simple string indices, the coordinates are <em>(index-pos,query-idx)</em> uint2 pairs</li>
<li>for string-set indices, the coordinates are <em>(index-id,index-pos,query-idx)</em> tuples represented as a uint4, where <em>index-id</em> and <em>index-pos</em> are the index into the string-set used to built the q-gram index.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Finally, the generated hits can be sorted and merged by diagonal bucket, effectively performing so called <em>q-gram counting</em>. <div class="fragment"><div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,hit_type&gt;</a>      hits( batch_size );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,diagonal_type&gt;</a> merged_hits( batch_size );</div>
<div class="line"><a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,uint16&gt;</a>        merged_counts( batch_size );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> hits_begin = 0; hits_begin &lt; n_hits; hits_begin += batch_size)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> hits_end = <a class="code" href="group___basic_utils.html#gaeeb2406339f4edfcee3f007aaccd478e">nvbio::min</a>( hits_begin + batch_size, n_hits );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// locate all hits in the range [hits_begin, hits_end)</span></div>
<div class="line">    qgram_filter.locate(</div>
<div class="line">        hits_begin,</div>
<div class="line">        hits_end,</div>
<div class="line">        hits.begin() );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// merge all hits within the same diagonal interval</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_merged = qgram_filter.merge(</div>
<div class="line">        16u,                <span class="comment">// merging interval</span></div>
<div class="line">        hits_end - hits_begin,</div>
<div class="line">        hits.begin(),</div>
<div class="line">        merged_hits.begin(),</div>
<div class="line">        merged_counts.begin() );</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="TechnicalOverviewSection"></a>
Technical Overview</h1>
<dl class="section user"><dt></dt><dd>A complete list of the classes and functions in this module is given in the <a class="el" href="group___q_gram.html">Q-Gram Module</a> documentation. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 20 2014 12:27:46 for NVBIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
