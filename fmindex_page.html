<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>NVBIO: FM-Index Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
  m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-47310325-1', 'nvlabs.github.io');
    ga('send', 'pageview');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NVBIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">NVBIO</a></li><li class="navelem"><a class="el" href="nvbio_page.html">NVBIO</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">FM-Index Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
 <img src="nvidia_cubes.png" style="position:relative; bottom:-10px; border:0px;"/>
<p><br/>
 This module defines a series of classes to represent and operate on 2-bit FM-indices, both from the host and device CUDA code.</p>
<h1><a class="anchor" id="RankDictionarySection"></a>
Rank Dictionaries</h1>
<dl class="section user"><dt></dt><dd>A <a class="el" href="structnvbio_1_1rank__dictionary.html">rank_dictionary</a> is a data structure that, given a text T, allows to count the number of occurrences of any given character c in a given prefix T[0,i] in O(1) time. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="structnvbio_1_1rank__dictionary.html">rank_dictionary</a> is <em>storage-free</em>, in the sense it doesn't directly hold any allocated data - hence it can be instantiated both on host and device data-structures, and it can be conveniently passed as a kernel parameter (provided its template parameters are also PODs). </dd></dl>
<dl class="section user"><dt></dt><dd>It supports the following functions: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><b>Function</b> </td><td style="vertical-align:text-top;"><b>Inputs</b> </td><td style="vertical-align:text-top;"><b>Description</b>  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a8cac81743120b36275cee02d66137fdd">rank()</a><br/>
 </td><td style="vertical-align:text-top;">dict, i, c </td><td style="vertical-align:text-top;">return the number of occurrences of a given character c in the prefix [0,i]  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a8cac81743120b36275cee02d66137fdd">rank()</a><br/>
 </td><td style="vertical-align:text-top;">dict, range, c </td><td style="vertical-align:text-top;">return the number of occurrences of a given character c in the prefixes [0,range.x] and [0,range.y]  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="group___f_m_index.html#ga0955aff9559ea69a5f51fb26faed11d5">rank_all()</a><br/>
 </td><td style="vertical-align:text-top;">dict, i </td><td style="vertical-align:text-top;">return the number of occurrences of all characters of the alphabet in the prefix [0,i]  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="group___f_m_index.html#ga0955aff9559ea69a5f51fb26faed11d5">rank_all()</a><br/>
 </td><td style="vertical-align:text-top;">dict, range </td><td style="vertical-align:text-top;">return the number of occurrences of all characters of the alphabet in the prefixes [0,range.x] and [0,range.y]  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><em>NOTE:</em> the O(1) time refers to the complexity in the length <em>n</em> of the text; more properly, if the alphabet contains <em>s</em> characters (i.e. if the number of bits per symbol is b = log(s)), the complexity is O(log(s)). Similarly, the amount of space needed for a sparse occurrence table is O(n s). In other words, the amount of space is exponential in the number of bits per character. </dd></dl>
<dl class="section user"><dt></dt><dd>For a more compact data structure requiring O(n log(s)) storage, useful with larger alphabets, please refer to <a class="el" href="strings_page.html#WaveletTreeSection">Wavelet Trees</a>.</dd></dl>
<h1><a class="anchor" id="SSASection"></a>
Sampled Suffix Arrays</h1>
<dl class="section user"><dt></dt><dd>A <em>Sampled <a class="el" href="structnvbio_1_1_suffix.html">Suffix</a> Array</em> is a succint suffix array which has been sampled at a subset of its indices. Ferragina &amp; Manzini showed that given such a data structure and the BWT of the original text it is possible to reconstruct the missing locations. Two such data structures have been proposed, with different tradeoffs:<ul>
<li>one storing only the entries that are a multiple of K, { SA[i] | SA[i] % K = 0 }</li>
<li>one storing only the entries whose index is a multiple of K, { SA[i] | i % K = 0 } </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>NVBIO provides both: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><a class="el" href="structnvbio_1_1_s_s_a__value__multiple.html">SSA_value_multiple</a></li>
<li><a class="el" href="structnvbio_1_1_s_s_a__index__multiple.html">SSA_index_multiple</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Unlike for the <a class="el" href="structnvbio_1_1rank__dictionary.html">rank_dictionary</a>, which is a storage-free class, these classes own the (internal) storage needed to represent the underlying data structures, which resides on the host. Similarly, the module provides some counterparts that hold the corresponding storage for the device: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><a class="el" href="structnvbio_1_1_s_s_a__value__multiple__device.html">SSA_value_multiple_device</a></li>
<li><a class="el" href="structnvbio_1_1_s_s_a__index__multiple__device.html">SSA_index_multiple_device</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>While these classes hold device data, they are meant to be used from the host and cannot be directly passed to CUDA kernels. Plain views (see <a class="el" href="host_device_page.html">Host &amp; Device</a>), or <em>contexts</em>, can be obtained with the usual <a class="el" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">plain_view()</a> function. </dd></dl>
<dl class="section user"><dt></dt><dd>The contexts expose the following interface: <div class="fragment"><div class="line"><span class="keyword">struct </span>SSA</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// return the i-th suffix array entry, if present</span></div>
<div class="line">    <span class="keywordtype">bool</span> fetch(<span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> i, <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a>&amp; r) <span class="keyword">const</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// return whether the i-th suffix array is present</span></div>
<div class="line">    <span class="keywordtype">bool</span> has(<span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> i) <span class="keyword">const</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Detailed documentation can be found in the <a class="el" href="group___s_s_a_module.html">Sampled Suffix Arrays</a> module documentation.</dd></dl>
<h1><a class="anchor" id="FMIndexSection"></a>
FM-Indices</h1>
<dl class="section user"><dt></dt><dd>An <a class="el" href="structnvbio_1_1fm__index.html">fm_index</a> is a self-compressed text index as described by Ferragina &amp; Manzini. It is built on top of the following ingredients:<ul>
<li>the BWT of a text T</li>
<li>a rank dictionary (<a class="el" href="structnvbio_1_1rank__dictionary.html">rank_dictionary</a> or <a class="el" href="structnvbio_1_1_wavelet_tree.html">WaveletTree</a>) of the given BWT</li>
<li>a sampled suffix array of T </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Given the above, it allows to count and locate all the occurrences in T of arbitrary patterns P in O(length(P)) time. Moreover, it does so with an incremental algorithm that proceeds character by character, a fundamental property that allows to implement sophisticated pattern matching algorithms based on backtracking. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="structnvbio_1_1fm__index.html">fm_index</a> is <em>storage-free</em>, in the sense it doesn't directly hold any allocated data - hence it can be instantiated both on host and device data-structures, and it can be conveniently passed as a kernel parameter (provided its template parameters are also PODs). </dd></dl>
<dl class="section user"><dt></dt><dd>It supports the following functions: <table class="doxtable">
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><b>Function</b> </td><td style="vertical-align:text-top;"><b>Inputs</b> </td><td style="vertical-align:text-top;"><b>Description</b>  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a8cac81743120b36275cee02d66137fdd">rank()</a><br/>
 </td><td style="vertical-align:text-top;">fmi, i, c </td><td style="vertical-align:text-top;">return the number of occurrences of a given character c in the prefix [0,i]  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="group___f_m_index.html#ga0955aff9559ea69a5f51fb26faed11d5">rank_all()</a><br/>
 </td><td style="vertical-align:text-top;">fmi, i </td><td style="vertical-align:text-top;">return the number of occurrences of all characters of the alphabet in the prefix [0,i]  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a10edbd2a2ecb580dcffbcf19898f80ea">match()</a><br/>
 </td><td style="vertical-align:text-top;">fmi, pattern </td><td style="vertical-align:text-top;">return the SA range of occurrences of a given pattern  </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a2514d704a5fd71cac1c2fb8fe0d34db0">match_reverse()</a><br/>
 </td><td style="vertical-align:text-top;">fmi, pattern </td><td style="vertical-align:text-top;">return the SA range of occurrences of a given reversed pattern   </td></tr>
<tr>
<td style="white-space: nowrap; vertical-align:text-top;"><a class="el" href="namespacenvbio.html#a94e8718b69ac72d7e76159a586ef64a6">locate()</a><br/>
 </td><td style="vertical-align:text-top;">fmi, i </td><td style="vertical-align:text-top;">given a suffix array coordinate i, return its linear coordinate SA[i]  </td></tr>
</table>
</dd></dl>
<p><a class="anchor" id="BidirectionalFMIndex"></a></p>
<h1><a class="anchor" id="BidirectionalFMIndexSection"></a>
Bidirectional FM-indices</h1>
<dl class="section user"><dt></dt><dd>NVBIO also supports forward and backwards extension using <a href="http://ieeexplore.ieee.org/xpls/icp.jsp?arnumber=5341875">bidirectional FM-indices</a>: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><a class="el" href="group___f_m_index.html#ga8f144b9bf95f1f52085b44980f82ca07">extend_forward()</a> : extend the range corresponding to a pattern P to that of the pattern Pc</li>
<li><a class="el" href="group___f_m_index.html#ga32fd67cdd5de3541c0dd0e3499c51bd5">extend_backwards()</a> : extend the range corresponding to a pattern P to that of the pattern cP </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Instead of requiring an ad-hoc data structure, bidirectional queries are supported by simply using both a forward and a reverse FM-index. Note that extension can be done without a sampled suffix array, so that there's no need to store two of them: in practice, the FM-indices can also be of type <a class="el" href="structnvbio_1_1fm__index.html">fm_index</a> &lt;RankDictionary,<a class="el" href="structnvbio_1_1null__type.html">null_type</a>&gt;.</dd></dl>
<p><a class="anchor" id="FMIndexFilters"></a></p>
<h1><a class="anchor" id="FMIndexFiltersSection"></a>
Batch Filtering</h1>
<dl class="section user"><dt></dt><dd>Performing massively parallel FM-index queries requires careful load balancing, as finding all occurrences of a given set of strings in a text is a one-to-many process with variable-rate data expansion. NVBIO offers simple host and device contexts to rank a set of strings and enumerate all their occurrences automatically: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><a class="el" href="structnvbio_1_1_f_m_index_filter_host.html">FMIndexFilterHost</a></li>
<li><a class="el" href="structnvbio_1_1_f_m_index_filter_device.html">FMIndexFilterDevice</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Here is an example showing how to extract a set of seeds from a string set and find their occurrences on the device: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> fm_index_type&gt;</div>
<div class="line"><span class="keywordtype">void</span> search_seeds(</div>
<div class="line">    <span class="keyword">const</span> fm_index_type     fm_index,           <span class="comment">// the input FM-index</span></div>
<div class="line">    <span class="keyword">const</span> string_set_type   string_set,         <span class="comment">// the input string-set</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a>            seed_len,           <span class="comment">// the seeds length</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a>            seed_interval)      <span class="comment">// the spacing between seeds</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,string_set_infix_coord_type&gt;</a>&amp;  seed_coords</div>
<div class="line"></div>
<div class="line">    <span class="comment">// enumerate all seeds</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gac34ecd066ef3371643ada1f73d9a2e96">uint32</a> n_seeds = <a class="code" href="group___string_sets_module.html#ga26375e5ce59fadcb3952faa10035a90c">enumerate_string_set_seeds</a>(</div>
<div class="line">        string_set,</div>
<div class="line">        uniform_seeds_functor&lt;&gt;( seed_len, seed_interval ),</div>
<div class="line">        seed_coords );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// and build the output infix-set</span></div>
<div class="line">    <span class="keyword">typedef</span> InfixSet&lt;string_set_type, const string_set_infix_coord_type*&gt; seed_set_type;</div>
<div class="line">    seed_set_type seeds(</div>
<div class="line">        n_seeds,</div>
<div class="line">        string_set,</div>
<div class="line">        <a class="code" href="group___packed_streams.html#gaa8a57b67f0319432f01a849df6699bfe">nvbio::plain_view</a>( seed_coords ) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the filter</span></div>
<div class="line">    FMIndexFilterDevice fm_filter;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// first step: rank the query seeds</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group___basic.html#gabceca7efbe8a079462f825131b2acccd">uint64</a> n_hits = fm_filter.rank( fm_index, seeds );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// prepare storage for the output hits</span></div>
<div class="line">    <a class="code" href="structnvbio_1_1vector.html">nvbio::vector&lt;device_tag,FMIndexFilterDevice::hit_type&gt;</a> hits( batch_size );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// loop through large batches of hits and locate &amp; merge them</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group___basic.html#gabceca7efbe8a079462f825131b2acccd">uint64</a> hits_begin = 0; hits_begin &lt; n_hits; hits_begin += batch_size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group___basic.html#gabceca7efbe8a079462f825131b2acccd">uint64</a> hits_end = <a class="code" href="group___basic_utils.html#gaeeb2406339f4edfcee3f007aaccd478e">nvbio::min</a>( hits_begin + batch_size, n_hits );</div>
<div class="line"></div>
<div class="line">        fm_filter.locate(</div>
<div class="line">            hits_begin,</div>
<div class="line">            hits_end,</div>
<div class="line">            hits.begin() );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// do something with the hits, e.g. extending them using DP alignment...</span></div>
<div class="line">        ...</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p><a class="anchor" id="MEMFilters"></a></p>
<h1><a class="anchor" id="MEMFiltersSection"></a>
MEM Filtering</h1>
<dl class="section user"><dt></dt><dd>Additionally to the exact matching filters above, NVBIO also some provides built-in functionality to find all (Super-) Maximal Extension Matches in a string or a string-set: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><a class="el" href="group___f_m_index.html#ga2883ef425905e8458473355f73119af2">find_kmems()</a> : a host/device per-thread function to find all k-MEMs overlapping a given base of a pattern string</li>
<li><a class="el" href="group___f_m_index.html#ga3e1b972c5d4d74136fbce81c8d7c34e4">find_threshold_kmems()</a> : a host/device per-thread function to find all k-MEMs overlapping a given base of a pattern string for all threshold values of k</li>
<li><a class="el" href="structnvbio_1_1_m_e_m_filter_host.html">MEMFilterHost</a> : a parallel host context to enumerate all MEMs of a string-set</li>
<li><a class="el" href="structnvbio_1_1_m_e_m_filter_device.html">MEMFilterDevice</a> : a parallel device context to enumerate all MEMs of a string-set </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The filters are analogous to the ones introduced in the previous section, except that rather than finding exact matches for each string in a set, they will find all their MEMs or SMEMs.</dd></dl>
<h1><a class="anchor" id="PerformanceSection"></a>
Performance</h1>
<dl class="section user"><dt></dt><dd>The graphs below show the performance of exact and approximate matching using the FM-index on the CPU and GPU, searching for 32bp fragments inside the whole human genome. Approximate matching is performed with the <a class="el" href="group___f_m_index.html#gadcbec0e8b809f645e81b62a3f0481470">hamming_backtrack()</a> function, in this case allowing up to 1 mismatch per fragment:</dd></dl>
<div class="image">
<img src="benchmark-fm-index.png"  style="position:relative; bottom:-10px; border:0px;" width="55%" height="55%"/>
</div>
 <div class="image">
<img src="benchmark-fm-index-speedup.png"  style="position:relative; bottom:-10px; border:0px;" width="55%" height="55%"/>
</div>
<h1><a class="anchor" id="TechnicalOverviewSection"></a>
Technical Overview</h1>
<dl class="section user"><dt></dt><dd>A complete list of the classes and functions in this module is given in the <a class="el" href="group___f_m_index.html">FMIndex</a> documentation. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 23 2015 19:36:54 for NVBIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
